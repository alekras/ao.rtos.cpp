6.2.7. Interrupt handlers
This section describes how to write interrupt handlers.
Levels of external interrupt
The ARM processor has two levels of external interrupt, FIQ and IRQ, both of which are level-sensitive active LOW signals 
into the processor. For an interrupt to be taken, the appropriate disable bit in the CPSR must be clear.
FIQs have higher priority than IRQs in the following ways:
FIQs are handled first when multiple interrupts occur.
Handling an FIQ causes IRQs and subsequent FIQs to be disabled, preventing them from being handled until after the FIQ handler 
enables them. This is usually done by restoring the CPSR from the SPSR at the end of the handler.
The FIQ vector is the last entry in the vector table so that the FIQ handler can be placed directly at the vector location 
and run sequentially from that address. This removes the requirement for a branch and its associated delay, and also means 
that if the system has a cache, the vector table and FIQ handler might all be locked down in one block within it. 
This is important because FIQs are designed to handle interrupts as quickly as possible. The five extra FIQ mode banked 
registers enable status to be held between calls to the handler, again increasing execution speed.
Note
An interrupt handler must contain code to clear the source of the interrupt.
Reentrant interrupt handlers
If an interrupt handler enables interrupts before calling a subroutine and another interrupt occurs, the return address 
of the subroutine stored in the IRQ mode LR is corrupted when the second IRQ is taken. This is because the processor automatically 
saves the return address into the IRQ mode LR for the new interrupt overwriting the return address for the subroutine. 
This results in an infinite loop when the subroutine in the original interrupt tries to return.
A reentrant interrupt handler must save the IRQ state, switch processor modes, and save the state for the new processor mode 
before branching to a nested subroutine or C function. It must also ensure that the stack is eight-byte aligned for 
the new processor mode before calling AAPCS-compliant compiled C code that might use LDRD or STRD instructions or eight-byte 
aligned stack-allocated data. There is more information about stack alignment issues in the ABI for 
the ARM Architecture Advisory Note 1- SP must be 8-byte aligned on entry to AAPCS-conforming functions (ARM IHI 0046A).
Using the __irq keyword in C does not cause the SPSR to be saved and restored, as required by reentrant interrupt handlers, 
so you must write your top level interrupt handler in assembly language.
In ARMv4 or later you can switch to System mode if you require privileged access. See System mode for more information.
Note
This method works for both IRQ and FIQ interrupts. However, because FIQ interrupts are meant to be handled as quickly as possible 
there is normally only one interrupt source, so it might not be necessary to provide for reentrancy.
The steps required to enable interrupts safely in an IRQ handler are:
Construct the return address and save it on the IRQ stack.
Save the work registers, non callee-saved registers and IRQ mode SPSR.
Clear the source of the interrupt.
Switch to System mode, keeping IRQs disabled.
Check that the stack is eight-byte aligned and adjust if necessary.
Save the User mode LR and the adjustment, 0 or 4 for Architectures v4 or v5TE, used on the User mode SP.
Enable interrupts and call the C interrupt handler function.
When the C interrupt handler returns, disable interrupts.
Restore the User mode LR and the stack adjustment value.
Readjust the stack if necessary.
Switch to IRQ mode.
Restore other registers and IRQ mode SPSR.
Return from the IRQ.
Example 6.2 and Example 6.3 shows how this works for System mode.
Example 6.2. Reentrant interrupt handler for ARMv4/v5TE
    PRESERVE8
    AREA INTERRUPT, CODE, READONLY
    IMPORT C_irq_handler
    IMPORT identify_and_clear_source

IRQ_Handler
    SUB     lr, lr, #4             ; construct the return address
    PUSH    {lr}                   ; and push the adjusted lr_IRQ
    MRS     lr, SPSR               ; copy spsr_IRQ to lr
    PUSH    {R0-R4,R12,lr}         ; save AAPCS regs and spsr_IRQ
    BL      identify_and_clear_source
    MSR     CPSR_c, #0x9F          ; switch to SYS mode, IRQ is
                                   ; still disabled. USR mode
                                   ; registers are now current.
    AND     R1, sp, #4             ; test alignment of the stack
    SUB     sp, sp, R1             ; remove any misalignment (0 or 4)
    PUSH    {R1,lr}                ; store the adjustment and lr_USR
    MSR     CPSR_c, #0x1F          ; enable IRQ
    BL      C_irq_handler
    MSR     CPSR_c, #0x9F          ; disable IRQ, remain in SYS mode
    POP     {R1,lr}                ; restore stack adjustment and lr_USR
    ADD     sp, sp, R1             ; add the stack adjustment (0 or 4)
    MSR     CPSR_c, #0x92          ; switch to IRQ mode and keep IRQ
                                   ; disabled. FIQ is still enabled.
    POP     {R0-R4,R12,lr}         ; restore registers and
    MSR     SPSR_cxsf, lr          ; spsr_IRQ
    LDM     sp!, {pc}^             ; return from IRQ.
    END

Example 6.3. Reentrant Interrupt for ARMv6 ( non vectored interrupts)
    PRESERVE8
    AREA INTERRUPT, CODE, READONLY
    IMPORT C_irq_handler
    IMPORT identify_and_clear_source

IRQ_Handler
    SUB         lr, lr, #4
    SRSDB       sp!,#31          ; Save LR_irq and SPSR_irq to System mode stack
    CPS #031                     ; Switch to System mode
    PUSH        {R0-R3,R12}      ; Store other AAPCS registers
    AND         R1, sp, #4
    SUB         sp, sp, R1
    PUSH        {R1, lr}
    BL          identify_and_clear_source
    CPSIE       i                ; Enable IRQ
    BL          C_irq_handler
    CPSID i                      ; Disable IRQ
    POP         {R1,lr}
    ADD         sp, sp, R1
    POP         {R0-R3, R12}     ; Restore registers
    RFEIA       sp!              ; Return using RFE from System mode stack
    END

These examples assume that FIQ remains permanently enabled.
Example interrupt handlers in assembly language
Interrupt handlers are often written in assembly language to ensure that they execute quickly. The following sections give 
some examples:
Single���channel DMA transfer
Dual���channel DMA transfer
Interrupt prioritization
Context switch.
Single-channel DMA transfer
Example 6.4 shows an interrupt handler that performs interrupt driven I/O to memory transfers, soft DMA. The code is 
an FIQ handler. It uses the banked FIQ registers to maintain state between interrupts. This code is best situated at location 0x1C.
In the example code:
R8
Points to the base address of the I/O device that data is read from.
IOData
Is the offset from the base address to the 32-bit data register that is read. Reading this register clears the interrupt.
R9
Points to the memory location to where that data is being transferred.
R10
Points to the last address to transfer to.
The entire sequence for handling a normal transfer is four instructions. Code situated after the conditional return 
is used to signal that the transfer is complete.
Example 6.4. FIQ handler
    LDR     R11, [R8, #IOData]     ; Load port data from the IO device.
    STR     R11, [R9], #4          ; Store it to memory: update the pointer.
    CMP     R9, R10                ; Reached the end ?
    SUBLSS  pc, lr, #4             ; No, so return.
                                   ; Insert transfer complete
                                   ; code here.

Byte transfers can be made by replacing the load instructions with load byte instructions. Transfers from memory to 
an I/O device are made by swapping the addressing modes between the load instruction and the store instruction.
Dual-channel DMA transfer
Example 6.5 is similar to Example 6.4, except that there are two channels being handled. The code is an FIQ handler.
 It uses the banked FIQ registers to maintain state between interrupts. It is best situated at location 0x1C.
In the example code:
R8
Points to the base address of the I/O device from which data is read.
IOStat
Is the offset from the base address to a register indicating which of two ports caused the interrupt.
IOPort1Active
Is a bit mask indicating if the first port caused the interrupt. Otherwise it is assumed that the second port caused the interrupt.
IOPort1, IOPort2
Are offsets to the two data registers to be read. Reading a data register clears the interrupt for the corresponding port.
R9
Points to the memory location to which data from the first port is being transferred.
R10
Points to the memory location to which data from the second port is being transferred.
R11, R12
Point to the last address to transfer to. This is R11 for the first port, R12 for the second.
The entire sequence to handle a normal transfer takes nine instructions. Code situated after the conditional return 
is used to signal that the transfer is complete.
Example 6.5. FIQ handler
    LDR     sp, [R8, #IOStat]      ; Load status register to find which port
                                   ; caused the interrupt.
    TST     sp, #IOPort1Active
    LDREQ   sp, [R8, #IOPort1]     ; Load port 1 data.
    LDRNE   sp, [R8, #IOPort2]     ; Load port 2 data.
    STREQ   sp, [R9], #4           ; Store to buffer 1.
    STRNE   sp, [R10], #4          ; Store to buffer 2.
    CMP     R9, R11                ; Reached the end?
    CMPLE   R10, R12               ; On either channel?
    SUBSNE  pc, lr, #4             ; Return
                                   ; Insert transfer complete code here.

Byte transfers can be made by replacing the load instructions with load byte instructions. Transfers from memory to 
an I/O device are made by swapping the addressing modes between the conditional load instructions and the conditional 
store instructions.
Interrupt prioritization
Example 6.6 dispatches up to 32 interrupt sources to their appropriate handlers. Because it is designed for use with 
the normal interrupt vector, IRQ, it is branched to from location 0x18.
External Vectored Interrupt Controller (VIC) hardware is used to prioritize the interrupt and present the high-priority 
active interrupt in an I/O register.
In the example code:
IntBase
Holds the base address of the interrupt controller.
IntLevel
Holds the offset of the register containing the highest-priority active interrupt.
R13
Is assumed to point to a small full descending stack.
Interrupts are enabled after ten instructions, including the branch to this code.
The specific handler for each interrupt is entered, with all registers preserved on the stack, after two more instructions.
In addition, the last three instructions of each handler are executed with interrupts turned off again, so that the SPSR 
can be safely recovered from the stack.
Note
Application Note 30: Software Prioritization of Interrupts describes multiple-source prioritization of interrupts using 
software, as opposed to using the VIC hardware as described here.
Example 6.6. Dispatching interrupts to handlers
    ; first save the critical state
    SUB     lr, lr, #4              ; Adjust the return address
                                    ; before we save it.
    STMDB   sp!, {lr}               ; Stack return address
    MRS     lr, SPSR                ; get the SPSR ...
    PUSH    {R12,lr}                ; ... and stack that plus a
                                    ; working register too.
                                    ; Now get the priority level of the
                                    ; highest priority active interrupt.
    MOV     R12, #IntBase           ; Get the interrupt controller's
                                    ; base address.
    LDR     R12, [R12, #IntLevel]   ; Get the interrupt level (0 to 31).
                                    ; Now read-modify-write the CPSR
                                    ; to enable interrupts.
    MRS     lr, APSR                ; Read the status register.
    BIC     lr, lr, #0x80           ; Clear the I bit
                                    ; (use 0x40 for the F bit).
    MSR     CPSR_c, lr              ; Write it back to re-enable
                                    ; interrupts and
    LDR     pc, [pc, R12, LSL #2]   ; jump to the correct handler.
                                    ; PC base address points to this
                                    ; instruction + 8
    NOP                             ; pad so the PC indexes this table.
                                    ; Table of handler start addresses
    DCD     Priority0Handler
    DCD     Priority1Handler
    DCD     Priority2Handler
; ...
    Priority0Handler
    PUSH    {R0-R11}                ; Save other working registers.
                                    ; Insert handler code here.
; ...
    POP     {R0-R11}                ; Restore working registers (not R12).
                                    ; Now read-modify-write the CPSR
                                    ; to disable interrupts.
    MRS     R12, APSR               ; Read the status register.
    ORR     R12, R12, #0x80         ; Set the I bit
                                    ; (use 0x40 for the F bit).
    MSR     CPSR_c, R12             ; Write it back to disable interrupts.
                                    ; Now that interrupt disabled, can safely
                                    ; restore SPSR then return.
    POP     {r12,lr}                ; Restore R12 and get SPSR.
    MSR     SPSR_cxsf, lr           ; Restore status register from R14.
    LDM     sp!, {pc}^              ; Return from handler.
Priority1Handler
; ...

Context switch
Example 6.7 performs a context switch on the User mode process. The code is based around a list of pointers to Process Control Blocks 
(PCBs) of processes that are ready to run.
Figure 6.2 shows the layout of the PCBs that the example expects.
Figure 6.2. PCB layout


The pointer to the PCB of the next process to run is pointed to by R12, and the end of the list has a zero pointer. 
Register R13 is a pointer to the PCB, and is preserved between time slices, so that on entry it points to the PCB of 
the currently running process.
Example 6.7. Context switch on the User mode process
    STM     sp,{R0-lr}^             ; Dump user registers above R13.
    MRS     R0, SPSR                ; Pick up the user status
    STMDB   sp, {R0, lr}            ; and dump with return address below.
    LDR     sp, [R12], #4           ; Load next process info pointer.
    CMP     sp, #0                  ; If it is zero, it is invalid
    LDMDBNE sp, {R0, lr}            ; Pick up status and return address.
    MSRNE   SPSR_cxsf, R0           ; Restore the status.
    LDMNE   sp, {R0 - lr}^          ; Get the rest of the registers
    NOP
    SUBSNE pc, lr, #4               ; and return and restore CPSR.
                                    ; Insert "no next process code" here.
